{% extends "base.html" %} {% block header_actions %}
<button
  id="clear-chat-btn"
  class="text-xs bg-opacity-50 bg-gray-700 hover:bg-gray-600 text-gray-300 py-1 px-3 rounded-md transition duration-200"
>
  Clear Chat
</button>
{% endblock %} {% block content %}
<div class="grid grid-cols-1 lg:grid-cols-5 gap-3 h-full">
  <!-- Code Editor - Left column (reduced width) -->
  <div class="glass-panel rounded-lg shadow-lg compact-p flex flex-col lg:col-span-3">
    <div class="flex justify-between items-center compact-mb">
      <h2 class="text-lg font-semibold text-indigo-300">MANIM Code</h2>
      <button
        id="execute-button"
        class="glass-button text-white py-1 px-3 rounded-md transition duration-200 focus:outline-none focus:ring-1 focus:ring-indigo-500 flex items-center gap-1 text-sm"
      >
        <span>Execute</span>
        <svg
          id="execute-spinner"
          class="animate-spin h-4 w-4 text-white hidden"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle
            class="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            stroke-width="4"
          ></circle>
          <path
            class="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          ></path>
        </svg>
      </button>
    </div>

    <!-- Status message shown directly under the header -->
    <div id="status-message" class="compact-mb hidden">
      <div class="px-3 py-1 rounded-md" id="status-container">
        <p id="status-text" class="text-xs">Processing...</p>
      </div>
    </div>

    <div
      id="code-editor-container"
      class="code-editor-container w-full flex-grow min-h-[450px]"
    >
      <textarea id="manim-code" class="hidden">
from manim import *

class CreateCircle(Scene):
    def construct(self):
        circle = Circle()
        circle.set_fill(PINK, opacity=0.5)
        self.play(Create(circle))</textarea
      >
    </div>
  </div>

  <!-- Right column: Video Player and Chat -->
  <div class="flex flex-col compact-gap lg:col-span-2">
    <!-- Video Player -->
    <div class="glass-panel rounded-lg shadow-lg compact-p flex flex-col">
      <h2 class="text-lg font-semibold text-indigo-300 compact-mb">
        Generated Video
      </h2>
      <div
        class="relative w-full aspect-video bg-black bg-opacity-50 rounded-md overflow-hidden flex items-center justify-center mb-2"
      >
        <div
          id="video-overlay"
          class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 hidden z-10"
        >
          <div class="text-center">
            <svg
              class="animate-spin h-8 w-8 text-indigo-400 mx-auto mb-2"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
            >
              <circle
                class="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                stroke-width="4"
              ></circle>
              <path
                class="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              ></path>
            </svg>
            <p class="text-indigo-300 text-sm">Generating animation...</p>
            <p class="text-gray-400 text-xs mt-1">This may take a moment</p>
          </div>
        </div>
        <video id="output-video" controls class="w-full h-full object-contain">
          <source src="#" type="video/mp4" />
        </video>
      </div>

      <!-- Terminal-style console for logs -->
      <div
        class="bg-gray-900 bg-opacity-60 backdrop-blur-sm rounded-md border border-gray-700 overflow-hidden"
      >
        <div
          class="flex justify-between items-center px-3 py-1 bg-gray-800 bg-opacity-60 border-b border-gray-700"
        >
          <div class="flex items-center gap-1">
            <div class="w-2 h-2 rounded-full bg-red-500 opacity-80"></div>
            <div class="w-2 h-2 rounded-full bg-yellow-500 opacity-80"></div>
            <div class="w-2 h-2 rounded-full bg-green-500 opacity-80"></div>
          </div>
          <span class="text-xs text-gray-400">Console</span>
          <div class="w-8"></div>
        </div>

        <div
          id="log-display"
          class="transition-opacity duration-300 opacity-0 max-h-0 overflow-hidden"
        >
          <div
            id="log-lines"
            class="p-2 font-mono text-xs text-green-300 space-y-1"
          ></div>
        </div>
      </div>
    </div>

    <!-- Chat Interface -->
    <div class="glass-panel rounded-lg shadow-lg compact-p flex flex-col flex-grow">
      <h2 class="text-lg font-semibold text-indigo-300 compact-mb">Chat</h2>
      <div
        id="chat-container"
        class="chat-container bg-gray-850 bg-opacity-60 backdrop-blur-sm rounded-md p-2 flex flex-col gap-1 compact-mb flex-grow overflow-y-auto min-h-[180px] max-h-[350px]"
      >
        <!-- Chat messages will be inserted here -->
        <div class="text-gray-500 text-center text-xs py-3">
          Start a conversation with AutoManim
        </div>
      </div>

      <div class="flex gap-2 mt-auto">
        <div class="flex-grow relative">
          <input
            type="text"
            placeholder="Enter your prompt..."
            id="manim-prompt"
            class="w-full py-1.5 px-3 glass-input rounded-md text-sm focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 focus:ring-opacity-50 outline-none"
          />
          <div
            id="generate-prompt-spinner"
            class="absolute right-3 top-1/2 transform -translate-y-1/2 hidden"
          >
            <svg
              class="animate-spin h-4 w-4 text-indigo-400"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
            >
              <circle
                class="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                stroke-width="4"
              ></circle>
              <path
                class="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              ></path>
            </svg>
          </div>
        </div>
        <button
          id="generate-button"
          type="button"
          class="glass-button text-white py-1.5 px-3 rounded-md flex items-center justify-center gap-1 transition duration-200 focus:outline-none focus:ring-1 focus:ring-indigo-500 whitespace-nowrap text-sm"
        >
          <span>Send</span>
          <svg
            id="generate-spinner"
            class="animate-spin h-4 w-4 text-white hidden"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              class="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              stroke-width="4"
            ></circle>
            <path
              class="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
        </button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

<script>
  document.addEventListener("DOMContentLoaded", () => {
    // Initialize CodeMirror
    const codeEditor = CodeMirror.fromTextArea(
      document.getElementById("manim-code"),
      {
        mode: "python",
        theme: "dracula",
        lineNumbers: true,
        indentUnit: 4,
        smartIndent: true,
        indentWithTabs: false,
        lineWrapping: true,
        matchBrackets: true,
        autoCloseBrackets: true,
        tabSize: 4,
        extraKeys: {
          Tab: function (cm) {
            if (cm.somethingSelected()) {
              cm.indentSelection("add");
            } else {
              cm.replaceSelection("    ", "end", "+input");
            }
          },
          "Ctrl-/": "toggleComment",
          "Cmd-/": "toggleComment",
        },
      }
    );

    const els = {
      executeButton: document.getElementById("execute-button"),
      generateButton: document.getElementById("generate-button"),
      clearChatButton: document.getElementById("clear-chat-btn"),
      codeEditor: codeEditor,
      outputVideo: document.getElementById("output-video"),
      statusMessage: document.getElementById("status-message"),
      statusText: document.getElementById("status-text"),
      statusContainer: document.getElementById("status-container"),
      manimPrompt: document.getElementById("manim-prompt"),
      executeSpinner: document.getElementById("execute-spinner"),
      generateSpinner: document.getElementById("generate-spinner"),
      generatePromptSpinner: document.getElementById("generate-prompt-spinner"),
      videoOverlay: document.getElementById("video-overlay"),
      chatContainer: document.getElementById("chat-container"),
    };

    const toggleLoading = (type, state) => {
      els[`${type}Spinner`].classList.toggle("hidden", !state);
      els[`${type}Button`].disabled = state;
      if (type === "execute")
        els.videoOverlay.classList.toggle("hidden", !state);
    };

    const showStatus = (type, message, timeout = 3000) => {
      els.statusContainer.className = `px-4 py-3 rounded-md bg-${type}-900 bg-opacity-50`;
      els.statusText.className = `text-${type}-300`;
      els.statusText.textContent = message;
      els.statusMessage.classList.remove("hidden");
      if (timeout)
        setTimeout(() => els.statusMessage.classList.add("hidden"), timeout);
    };

    // Add a message to the chat container
    const addChatMessage = (message, role) => {
      const messageDiv = document.createElement("div");
      messageDiv.className =
        role === "user"
          ? "user-message p-3 text-white"
          : "assistant-message p-3 text-gray-200";

      if (role === "user") {
        messageDiv.textContent = message;
      } else {
        // Count lines and show compact preview
        const codeLines = message
          .split("\n")
          .filter((line) => line.trim() !== "");
        const numLines = codeLines.length;

        messageDiv.innerHTML = `<div class="code-preview">
          <p class="text-xs font-mono flex items-center">
            <span class="text-indigo-300 mr-2"><i>Code generated:</i></span>
            <span class="bg-gray-700 px-2 py-1 rounded">${numLines} lines</span>
          </p>
        </div>`;
      }

      els.chatContainer.appendChild(messageDiv);
      // Scroll to the bottom
      els.chatContainer.scrollTop = els.chatContainer.scrollHeight;
    };

    // Fetch chat history on page load
    const fetchChatHistory = async () => {
      try {
        const response = await fetch("/get_chat_history");
        if (response.ok) {
          const data = await response.json();
          if (data.chat_history && data.chat_history.length > 0) {
            // Clear initial message
            els.chatContainer.innerHTML = "";

            // Add messages to chat
            data.chat_history.forEach((message) => {
              addChatMessage(message.content, message.role);
            });
          }
        }
      } catch (error) {
        console.error("Failed to fetch chat history:", error);
      }
    };

    // Clear chat history
    const clearChatHistory = async () => {
      try {
        const response = await fetch("/clear_chat_history", {
          method: "POST",
        });
        if (response.ok) {
          els.chatContainer.innerHTML = `
            <div class="text-gray-500 text-center text-sm py-4">
              Start a conversation with AutoManim
            </div>
          `;
        }
      } catch (error) {
        console.error("Failed to clear chat history:", error);
      }
    };

    async function executeManim() {
      toggleLoading("execute", true);
      showStatus("indigo", "Executing Manim code...", false);
      try {
        const res = await fetch("/execute_manim", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ code: els.codeEditor.getValue() }),
        });
        const data = await res.json();
        if (res.ok) {
          els.outputVideo.querySelector("source").src =
            data.video_url + "?t=" + Date.now();
          els.outputVideo.load();
          els.outputVideo.play();
          showStatus("green", "Animation generated successfully!");
        } else throw new Error(data.error || "Failed to execute Manim code");
      } catch (e) {
        showStatus("red", e.message, false);
      } finally {
        toggleLoading("execute", false);
      }
    }

    async function generateManim() {
      if (!els.manimPrompt.value.trim())
        return showStatus("red", "Please enter a prompt", false);
      toggleLoading("generate", true);
      showStatus("indigo", "Generating Manim code...", false);

      // Add user message to chat interface immediately
      addChatMessage(els.manimPrompt.value.trim(), "user");

      try {
        const res = await fetch("/generate_manim_code", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ manimPrompt: els.manimPrompt.value }),
        });
        const data = await res.json();
        if (res.ok) {
          els.codeEditor.setValue(data.code);
          // Refresh the editor to update display
          els.codeEditor.refresh();

          // Add assistant response to chat
          addChatMessage(data.code, "assistant");

          // Clear the input field
          els.manimPrompt.value = "";
        } else throw new Error(data.error || "Failed to generate Manim code");
        showStatus("green", "Code generated successfully!");
      } catch (e) {
        showStatus("red", e.message, false);
      } finally {
        toggleLoading("generate", false);
      }
    }

    // Event listeners
    els.executeButton.addEventListener("click", executeManim);
    els.generateButton.addEventListener("click", generateManim);
    els.manimPrompt.addEventListener("keypress", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        generateManim();
      }
    });
    els.clearChatButton.addEventListener("click", clearChatHistory);

    // Load chat history on page load
    fetchChatHistory();
  });
</script>
